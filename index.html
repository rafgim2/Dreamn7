<!doctype html> 
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>XR AR Video + MIDI + Marco + PartÃ­culas + Cometa Intro (rastro atraÃ­do al espectador)</title>

<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Arial}
  #overlay{
    position:fixed;inset:0;display:grid;place-items:center;
    background:rgba(0,0,0,.85);color:#fff;z-index:10;text-align:center;padding:24px;
  }
  .card{
    background:rgba(255,255,255,.08);
    padding:24px;
    border-radius:22px;
    max-width:700px;
    width:90%;

    border:2px solid rgba(190, 150, 255, 0.85);
box-shadow:
  0 0 18px rgba(160, 90, 255, 0.45),
  inset 0 0 12px rgba(230, 210, 255, 0.25);
}
  button{
    padding:14px 18px;border-radius:14px;
    border:1px solid rgba(255,255,255,.2);
    background:rgba(255,255,255,.12);
    color:#fff;cursor:pointer;margin:6px;
  }
  .small{opacity:.75;font-size:14px;margin-top:10px;text-align:left;white-space:pre-wrap}
  #log{display:none !important;}
</style>
</head>

<body>
<div id="overlay">
  <div class="card">
        <img src="./DREAMSAR.png" alt="Dreams AR" style="width:70%; border-radius:18px; margin:0 auto 20px auto; display:block;">
    <p style="margin:0 0 20px 0;opacity:.9;font-size:18px;">
      
    </p>
    <button id="startExperience">ðŸŒŸ Iniciar experiencia</button>
    <div class="small" id="log"></div>

    <div class="small" id="log"></div>
      <div style="margin-top:18px; text-align:right; font-size:14px; opacity:.75;">
      <a href="https://www.youtube.com/@rafgim" target="_blank" style="color:#d9c8ff; text-decoration:none;">
        Â© By Rafael Gimeno
      </a>
    </div>

</div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { VIDEO_URL, CUES } from "./cues.js";

const overlay = document.getElementById("overlay");
const logEl = document.getElementById("log");
const log = (m) => { logEl.textContent += (logEl.textContent ? "\n" : "") + m; };

// ==================== CONFIG MIDI/HÃPTICA ====================
const MIDI_RIGHT_URL = "./dream14iz.mid";
const MIDI_LEFT_URL  = "./dream147.mid";

const MIDI_OFFSET_RIGHT = 3.4;
const MIDI_OFFSET_LEFT  = 3.4;
const HAPTIC_INTENSITY = 0.35;
const HAPTIC_DURATION_MS = 18;

const HAPTIC_WINDOW = 0.020;
const MIN_PULSE_GAP = 0.010;

const MOBILE_VIBRATION_MS = 22;
const MOBILE_MIN_GAP = 0.055;

// ==================== FUENTE PRISTINA (no bloqueante) ====================
let FONT_READY = false;
function loadPristinaFontNonBlocking(){
  try{
    const f = new FontFace("PristinaAR","url(./PRISTINA.TTF)");
    f.load().then(() => {
      document.fonts.add(f);
      FONT_READY = true;
      log("âœ… Fuente PRISTINA cargada");
    }).catch(() => log("âš ï¸ PRISTINA.TTF no cargÃ³ (fallback)"));
  }catch{
    log("âš ï¸ FontFace no disponible (fallback)");
  }
}
const fontName = () => FONT_READY ? "PristinaAR" : "serif";

// ==================== THREE / XR ====================
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, premultipliedAlpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = null;

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 50);
camera.position.set(0, 1.6, 2);

scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 1.2));

// ==================== VIDEO + AUDIO ====================
const video = document.createElement("video");
video.src = VIDEO_URL;
video.crossOrigin = "anonymous";
video.loop = false; // âœ… NO LOOP
video.preload = "auto";
video.playsInline = true;
video.setAttribute("playsinline","");
video.setAttribute("webkit-playsinline","");
video.muted = false;
video.volume = 1.0;

video.style.position = "fixed";
video.style.left = "-9999px";
video.style.top = "-9999px";
video.width = 1; video.height = 1;
document.body.appendChild(video);

video.addEventListener("error", () => {
  const e = video.error;
  log("âŒ Error video: " + (e ? (e.code + " " + e.message) : "desconocido"));
});

const videoTex = new THREE.VideoTexture(video);
videoTex.colorSpace = THREE.SRGBColorSpace;

// âœ… Al terminar: salir de AR/VR automÃ¡ticamente
video.addEventListener("ended", async () => {
  log("â¹ VÃ­deo finalizado â†’ saliendo de la experiencia");

  const s = renderer.xr.getSession?.();
  if (s){
    try{ await s.end(); }catch{}
  }

  overlay.style.display = "grid";
  btnAR.disabled = true;
  btnVR.disabled = true;

  // âœ… Permite reiniciar SIN recargar:
  NEEDS_RELOAD_AFTER_END = true; // (mantengo el nombre para no romper nada existente)
  resetExperienceState();
});

// ===== MÃ¡scara redondeada para recortar el vÃ­deo =====
function makeRoundedAlphaMask(size = 512, r = 70){
  const c = document.createElement("canvas");
  c.width = size; c.height = size;
  const ctx = c.getContext("2d");

  ctx.clearRect(0,0,size,size);
  ctx.fillStyle = "black";
  ctx.fillRect(0,0,size,size);

  const x = 0, y = 0, w = size, h = size;
  const rad = r;

  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.moveTo(x+rad, y);
  ctx.lineTo(x+w-rad, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+rad);
  ctx.lineTo(x+w, y+h-rad);
  ctx.quadraticCurveTo(x+w, y+h, x+w-rad, y+h);
  ctx.lineTo(x+rad, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-rad);
  ctx.lineTo(x, y+rad);
  ctx.quadraticCurveTo(x, y, x+rad, y);
  ctx.closePath();
  ctx.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}
const videoMaskTex = makeRoundedAlphaMask(512, 30);

// ==================== PANTALLA ====================
const screenW = 1.6;
const screenH = 0.9;

const screenMat = new THREE.MeshBasicMaterial({
  map: videoTex,
  alphaMap: videoMaskTex,
  transparent: true,
  alphaTest: 0.02,
});

const screen = new THREE.Mesh(
  new THREE.PlaneGeometry(screenW, screenH),
  screenMat
);
screen.position.set(0, 1.55, -1.55);
scene.add(screen);

// ==================== ESQUINAS DEL VÃDEO (WORLD) ====================
const cornerTL = new THREE.Vector3();
const cornerTR = new THREE.Vector3();
const cornerBL = new THREE.Vector3();
const cornerBR = new THREE.Vector3();

function updateVideoCornersWorld(){
  screen.updateMatrixWorld(true);
  cornerTL.set(-screenW/2,  screenH/2, 0.0001); screen.localToWorld(cornerTL);
  cornerTR.set( screenW/2,  screenH/2, 0.0001); screen.localToWorld(cornerTR);
  cornerBL.set(-screenW/2, -screenH/2, 0.0001); screen.localToWorld(cornerBL);
  cornerBR.set( screenW/2, -screenH/2, 0.0001); screen.localToWorld(cornerBR);
}
scene.updateMatrixWorld(true);
  updateVideoCornersWorld();

// ==================== MARCO REDONDEADO GRADIENTE ====================
const frameGroup = new THREE.Group();
frameGroup.position.copy(screen.position);
frameGroup.rotation.copy(screen.rotation);
scene.add(frameGroup);

const margin = 0.010;
const border = 0.020;
const radius = 0.070;
const zFront = 0.003;

const gradCanvas = document.createElement("canvas");
gradCanvas.width = 512; gradCanvas.height = 512;
const gctx = gradCanvas.getContext("2d");
const gradTex = new THREE.CanvasTexture(gradCanvas);
gradTex.colorSpace = THREE.SRGBColorSpace;
gradTex.minFilter = THREE.LinearFilter;
gradTex.magFilter = THREE.LinearFilter;

function drawGradient(phase, energy){
  gctx.clearRect(0,0,512,512);

  // Gradiente horizontal: IZQ blanco â†’ DER morado (con una leve animaciÃ³n)
  const wob = 0.08 * Math.sin(phase * 1.25);
  const a = 0.90 + energy * 0.08;

  const grd = gctx.createLinearGradient(0, 256, 512, 256);

  // IZQUIERDA (blanco/lavanda)
  grd.addColorStop(0.00, `rgba(255, 255, 255, ${a})`);
  grd.addColorStop(0.28 + wob*0.3, `rgba(235, 225, 255, ${a})`);

  // CENTRO (lavanda)
  grd.addColorStop(0.52, `rgba(205, 175, 255, ${a})`);

  // DERECHA (morado)
  grd.addColorStop(0.78 - wob*0.3, `rgba(170, 90, 255, ${a})`);
  grd.addColorStop(1.00, `rgba(120, 40, 255, ${a})`);

  gctx.fillStyle = grd;
  gctx.fillRect(0,0,512,512);

  // Sutil "hotspot" que se mueve con phase/energy
  const cx = 256 + Math.cos(phase*0.9) * 40;
  const cy = 256 + Math.sin(phase*0.9) * 40;
  const rg = gctx.createRadialGradient(cx, cy, 0, cx, cy, 220);
  rg.addColorStop(0.0, `rgba(255,255,255, ${0.10 + energy*0.10})`);
  rg.addColorStop(1.0, "rgba(0,0,0,0)");
  gctx.fillStyle = rg;
  gctx.fillRect(0,0,512,512);

  gradTex.needsUpdate = true;
}

function roundedRectShape(w,h,r){
  const x = -w/2, y = -h/2;
  const s = new THREE.Shape();
  s.moveTo(x+r, y);
  s.lineTo(x+w-r, y);
  s.quadraticCurveTo(x+w, y, x+w, y+r);
  s.lineTo(x+w, y+h-r);
  s.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  s.lineTo(x+r, y+h);
  s.quadraticCurveTo(x, y+h, x, y+h-r);
  s.lineTo(x, y+r);
  s.quadraticCurveTo(x, y, x+r, y);
  return s;
}

const outerW = screenW + margin*2;
const outerH = screenH + margin*2;
const innerW = outerW - border*2;
const innerH = outerH - border*2;

const outer = roundedRectShape(outerW, outerH, radius);
const hole  = roundedRectShape(innerW, innerH, Math.max(0.001, radius - border));
outer.holes.push(hole);

const frameGeo = new THREE.ShapeGeometry(outer);
const frameMat = new THREE.MeshBasicMaterial({ map: gradTex, transparent:true, opacity:0.85 });
const frameMesh = new THREE.Mesh(frameGeo, frameMat);
frameMesh.position.set(0,0,zFront);
frameGroup.add(frameMesh);

let frameEnergy = 0;
let framePhase = 0;

// ==================== HELPERS COLOR/GRADIENTE ANIMADO ====================
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function rgb(r,g,b,a=1){ return `rgba(${r|0},${g|0},${b|0},${a})`; }

function makeAnimatedTitleGradient(ctx, phase, w, h){
  const ang = phase * 0.20;
  const cx = w * 0.5, cy = h * 0.5;
  const dx = Math.cos(ang) * w * 0.55;
  const dy = Math.sin(ang) * h * 0.55;

  const g = ctx.createLinearGradient(cx - dx, cy - dy, cx + dx, cy + dy);

  const p = 0.5 + 0.5 * Math.sin(phase * 0.85);
  const band = 0.16;

  const a0 = clamp(p - band*2.0, 0, 1);
  const a1 = clamp(p - band*0.6, 0, 1);
  const a2 = clamp(p,            0, 1);
  const a3 = clamp(p + band*0.6, 0, 1);
  const a4 = clamp(p + band*2.0, 0, 1);

  // Paleta morado â†” blanco (halo)
  const deep   = [120,  40, 255];
  const mid    = [170,  90, 255];
  const lilac  = [210, 175, 255];
  const white  = [255, 255, 255];

  g.addColorStop(0.00, rgb(deep[0],  deep[1],  deep[2],  0.98));
  g.addColorStop(a0,   rgb(deep[0],  deep[1],  deep[2],  0.98));
  g.addColorStop(a1,   rgb(mid[0],   mid[1],   mid[2],   0.99));
  g.addColorStop(a2,   rgb(white[0], white[1], white[2], 0.99));
  g.addColorStop(a3,   rgb(lilac[0], lilac[1], lilac[2], 0.99));
  g.addColorStop(a4,   rgb(mid[0],   mid[1],   mid[2],   0.98));
  g.addColorStop(1.00, rgb(deep[0],  deep[1],  deep[2],  0.98));

  return g;
}

function makeAnimatedGlowColor(phase, alpha){
  const t = 0.5 + 0.5*Math.sin(phase * 0.7);
  const r = lerp(255, 170, t); // blanco -> lilac
  const g = lerp(255,  90, t);
  const b = lerp(255, 255, t);
  return `rgba(${r|0},${g|0},${b|0},${alpha})`;
}

// ==================== TEXTO â€œESCRITURAâ€ + FADE OUT ====================
const TEXT_FADE_DELAY = 10.0;
const TEXT_FADE_DUR   = 1.4;
const pad = 36;
const TEXT_Z = -1.25;
const TEXT_Y_TEXT  = 1.65;
const TEXT_Y_TITLE = 1.64;

const TYPE_CPS_MIN = 8;
const TYPE_CPS_MAX = 14;

let activeType = "text";
let activeFontPx = 56;
let activeLineH = 78;

let cursor = 0, nextT = 0;
let prevVideoT = 0;

const textObjects = [];
let activeObj = null;

let titleGlowTex = null;

function makeGlowTexture(){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const cx = c.getContext("2d");
  cx.clearRect(0,0,256,256);

  const g = cx.createRadialGradient(128,128,0,128,128,110);
  g.addColorStop(0.0, "rgba(255, 255, 255, 0.60)");
  g.addColorStop(0.35,"rgba(210, 175, 255, 0.28)");
  g.addColorStop(0.65,"rgba(170, 90, 255, 0.18)");
  g.addColorStop(1.0, "rgba(0, 0, 0, 0)");

  cx.fillStyle = g;
  cx.fillRect(0,0,256,256);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}

function setupText(lines, type = "text"){
  activeType = type || "text";
  const isTitle = activeType === "title";

  activeFontPx = isTitle ? 96 : 56;
  activeLineH  = isTitle ? 112 : 78;

  const fullLines = Array.isArray(lines) ? lines : [String(lines)];

  const mctx = document.createElement("canvas").getContext("2d");
  mctx.font = `${activeFontPx}px ${fontName()}`;
  const fullWidths = fullLines.map(l => mctx.measureText(l).width);

  const w = Math.ceil(Math.max(...fullWidths) + pad*2);
  const h = Math.ceil(fullLines.length * activeLineH + pad*2 + (isTitle ? 40 : 0));

  const canvas = document.createElement("canvas");
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext("2d");

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.generateMipmaps = false;

  const aspect = w / h;
  const physicalH = isTitle ? 0.36 : 0.30;
  const physicalW = physicalH * aspect;

  const mat = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    depthWrite: false,
    opacity: 1.0
  });

  const plane = new THREE.Mesh(new THREE.PlaneGeometry(physicalW, physicalH), mat);
  plane.position.set(0, isTitle ? TEXT_Y_TITLE : TEXT_Y_TEXT, TEXT_Z);
  scene.add(plane);

  let glowMesh = null;
  if (isTitle){
    if (!titleGlowTex) titleGlowTex = makeGlowTexture();

    const gm = new THREE.MeshBasicMaterial({
      map: titleGlowTex,
      transparent: true,
      depthWrite: false,
      depthTest: false,
      blending: THREE.AdditiveBlending,
      opacity: 1.0
    });

    const gw = physicalW * 1.25;
    const gh = physicalH * 1.55;

    glowMesh = new THREE.Mesh(new THREE.PlaneGeometry(gw, gh), gm);
    glowMesh.renderOrder = 998;
    glowMesh.position.set(plane.position.x, plane.position.y, plane.position.z - 0.01);
    glowMesh.quaternion.copy(plane.quaternion);
    scene.add(glowMesh);
  }

  const obj = {
    plane, mat, texture, canvas, ctx,
    fullLines, fullWidths,
    fullText: fullLines.join("\n"),
    isTitle,
    createdAt: video.currentTime,
    lifePhase: 0,
    lastDrawChars: 0,
    glowMesh
  };

  textObjects.push(obj);

  activeObj = obj;
  cursor = 0;
  nextT = 0;
  drawObj(activeObj, 0);
}

function drawObj(obj, chars){
  if (!obj) return;

  obj.lastDrawChars = chars;

  const { ctx, canvas, texture, fullLines, fullWidths, fullText, isTitle } = obj;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.font = `${activeFontPx}px ${fontName()}`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  function drawLine(str, x, y){
    if (!isTitle){
      ctx.fillStyle = "rgba(255,255,255,0.96)";
      ctx.shadowColor = "rgba(0,0,0,0.85)";
      ctx.shadowBlur = 20;
      ctx.fillText(str, x, y);
      return;
    }

    const phase = obj.lifePhase;
    const pulse = 0.5 + 0.5*Math.sin(phase * 2.0);
    const glowBoost = 0.95 + 0.35*pulse;

    const glowBig = makeAnimatedGlowColor(phase, 0.28);
    const glowMid = makeAnimatedGlowColor(phase, 0.55);

    ctx.save();
    ctx.fillStyle = glowBig;
    ctx.shadowColor = glowBig;
    ctx.shadowBlur = 58 * glowBoost;
    ctx.fillText(str, x, y);
    ctx.restore();

    ctx.save();
    ctx.fillStyle = glowMid;
    ctx.shadowColor = glowMid;
    ctx.shadowBlur = 30 * glowBoost;
    ctx.fillText(str, x, y);
    ctx.restore();

    ctx.save();
    ctx.lineWidth = Math.max(2, activeFontPx * 0.06);
    ctx.strokeStyle = "rgba(40, 90, 180, 0.30)";
    ctx.shadowBlur = 0;
    ctx.strokeText(str, x, y);
    ctx.restore();

    ctx.save();
    const grad = makeAnimatedTitleGradient(ctx, phase, canvas.width, canvas.height);
    ctx.fillStyle = grad;
    ctx.shadowColor = "rgba(0,0,0,0.35)";
    ctx.shadowBlur = 6;
    ctx.fillText(str, x, y);
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = "rgba(230,245,255,1.0)";
    ctx.shadowColor = "rgba(180,220,255,0.9)";
    ctx.shadowBlur = 14 * glowBoost;
    ctx.fillText(str, x, y);
    ctx.restore();
  }

  const visible = fullText.slice(0, chars).split("\n");
  const cx = canvas.width / 2;
  let y = pad + activeLineH/2;

  for (let i=0;i<fullLines.length;i++){
    const full = fullLines[i];
    const vis  = visible[i] || "";
    const left = cx - fullWidths[i]/2;
    const vw   = ctx.measureText(vis).width;

    ctx.save();
    ctx.beginPath();
   ctx.rect(left, y - activeLineH/2, vw, activeLineH * (isTitle ? 1.65 : 1.0));
    if (!isTitle) ctx.clip();


    drawLine(full, cx, y);

    ctx.restore();
    y += activeLineH;
  }

  texture.needsUpdate = true;
}

function randomCps(){ return TYPE_CPS_MIN + Math.random() * (TYPE_CPS_MAX - TYPE_CPS_MIN); }

function stepType(dt){
  if (!activeObj) return;
  const fullText = activeObj.fullText;
  if (!fullText || cursor >= fullText.length) return;

  nextT -= dt;
  while (nextT <= 0 && cursor < fullText.length){
    cursor++;
    drawObj(activeObj, cursor);
    nextT += 1 / randomCps();
  }
}

function updateTitleLives(dt){
  const FPS = 24;

  for (const o of textObjects){
    if (!o.isTitle) continue;

    const prev = o.lifePhase;
    o.lifePhase += dt;

    if (o.glowMesh){
      const pulse = 0.5 + 0.5*Math.sin(o.lifePhase * 2.0);
      o.glowMesh.material.opacity = o.mat.opacity * (0.78 + 0.30*pulse);

      const s = 1.0 + 0.02*pulse;
      o.glowMesh.scale.set(s, 1.0 + 0.03*pulse, 1);
    }

    if (Math.floor(o.lifePhase * FPS) !== Math.floor(prev * FPS)){
      drawObj(o, o.lastDrawChars);
    }
  }
}

function updateTextFadeAndCleanup(t){
  for (let i = textObjects.length - 1; i >= 0; i--){
    const o = textObjects[i];
    const age = t - o.createdAt;

    let op = 1.0;
    if (age > TEXT_FADE_DELAY){
      const k = (age - TEXT_FADE_DELAY) / TEXT_FADE_DUR;
      op = 1.0 - clamp(k, 0, 1);
    }

    o.mat.opacity = op;
    o.plane.visible = op > 0.001;

    if (o.glowMesh){
      o.glowMesh.visible = op > 0.001;
      if (op <= 0.001) o.glowMesh.material.opacity = 0.0;
    }

    if (age > TEXT_FADE_DELAY + TEXT_FADE_DUR + 0.15){
      scene.remove(o.plane);
      o.plane.geometry.dispose();
      o.mat.dispose();
      o.texture.dispose();

      if (o.glowMesh){
        scene.remove(o.glowMesh);
        o.glowMesh.geometry.dispose();
        o.glowMesh.material.dispose();
      }

      textObjects.splice(i, 1);
      if (activeObj === o) activeObj = null;
    }
  }
}

// ==================== CUES ====================
const cues = [...CUES].sort((a,b)=>a.t-b.t);
let nextCue = 0;

// ==================== MIDI LIB + CARGA ====================
let MidiLib = null;
async function loadMidiLib(){
  if (MidiLib) return;
  log("â³ Cargando librerÃ­a MIDIâ€¦");
  MidiLib = await import("https://esm.sh/@tonejs/midi@2.0.28?bundle");
  log("âœ… LibrerÃ­a MIDI lista");
}
async function loadMidiTimes(url){
  await loadMidiLib();
  const { Midi } = MidiLib;
  const res = await fetch(url);
  if (!res.ok) throw new Error("No se pudo cargar " + url);
  const ab = await res.arrayBuffer();
  const midi = new Midi(ab);
  const times = [];
  for (const track of midi.tracks){
    for (const n of track.notes) times.push(n.time);
  }
  times.sort((a,b)=>a-b);
  return times;
}

// ==================== CONTROLLERS (Quest) ====================
const grip0 = renderer.xr.getControllerGrip(0);
const grip1 = renderer.xr.getControllerGrip(1);
scene.add(grip0);
scene.add(grip1);

let controllerRightObj = null;
let controllerLeftObj  = null;

function mapGrips(session){
  controllerRightObj = null;
  controllerLeftObj  = null;

  const pointers = [];
  for (const src of session.inputSources){
    if (src.targetRayMode === "tracked-pointer") pointers.push(src);
  }
  for (let i=0;i<pointers.length;i++){
    const src = pointers[i];
    const obj = (i === 0) ? grip0 : grip1;
    if (src.handedness === "right") controllerRightObj = obj;
    if (src.handedness === "left")  controllerLeftObj  = obj;
  }

  log(controllerRightObj ? "ðŸŽ® Mando derecho mapeado" : "â„¹ï¸ Sin mando derecho (modo mÃ³vil/hand-tracking)");
  log(controllerLeftObj  ? "ðŸŽ® Mando izquierdo mapeado" : "â„¹ï¸ Sin mando izquierdo (modo mÃ³vil/hand-tracking)");
}

// ==================== PARTÃCULAS (shader + fade + atracciÃ³n por partÃ­cula) ====================
const MAX_PARTICLES = 260;
const P_SPAWN = 3;
const P_LIFE = 10;

const PARTICLE_SPEED = 0.55;
const TARGET_BIAS_PUSH = 0.045;
const TARGET_ATTRACT   = 0.20;

// Viewer extra (MIDI izq)
const LEFT_VIEWER_PARTICLES = true;
const LEFT_VIEWER_SPAWNS_PER_HIT = 1;
const LEFT_VIEWER_SPAWN_PROB = 0.85;

const VIEWER_Z_NEAR = 0.55;
const VIEWER_Z_FAR  = 1.35;
const VIEWER_X_MAX  = 0.75;
const VIEWER_Y_MAX  = 0.45;

// ==================== TÃTULO: PARTÃCULAS ALEATORIAS (2â€“14s) ====================
const TITLE_PARTICLES_START = 2.0;
const TITLE_PARTICLES_END   = 14.0;

const TITLE_PARTICLE_RATE = 18;
const TITLE_PARTICLE_LIFE = 3.6;
const TITLE_PARTICLE_WARM = 0.95;

const TITLE_Z_NEAR = 0.75;
const TITLE_Z_FAR  = 1.25;
const TITLE_X_MAX  = 0.42;
const TITLE_Y_MAX  = 0.22;

const TITLE_TO_VIEWER_Z_NEAR = 0.18;
const TITLE_TO_VIEWER_Z_FAR  = 0.40;
const TITLE_TO_VIEWER_X_MAX  = 0.18;
const TITLE_TO_VIEWER_Y_MAX  = 0.10;
const TITLE_TO_VIEWER_ATTR_MUL = 2.6;
const TITLE_TO_VIEWER_PUSH = 0.18;

let titleAcc = 0;

// alternancia de color para partÃ­culas de entorno/cometa
let ENV_ALT = 0;
let COMET_ALT = 0;

// ==================== COMETA INTRO (0â€“14s) ====================
const INTRO_NO_MIDI_SECONDS = 5.0;
const COMET_ENABLED = true;
const COMET_TURNS = 1.0;
const COMET_SPRITE_SCALE = 0.14;

const COMET_TRAIL_RATE = 220;
const COMET_TRAIL_LIFE = 3.4;
const COMET_TRAIL_WARM = 0.95;

const COMET_ATTRACT_MUL = 4.0;
const COMET_TO_VIEWER_PUSH = 0.28;

const COMET_END_Z = 0.55;
const COMET_END_Y = 0.06;

function makeSpriteTexture(){
  const c = document.createElement("canvas");
  c.width = 64; c.height = 64;
  const cx = c.getContext("2d");
  cx.clearRect(0,0,64,64);
  const g = cx.createRadialGradient(32,32,0,32,32,30);

  // Importante: el shader usa principalmente tex.a (alpha). Dejamos RGB neutro (blanco).
  g.addColorStop(0.0,"rgba(255,255,255,1)");
  g.addColorStop(0.6,"rgba(255,255,255,0.40)");
  g.addColorStop(1.0,"rgba(255,255,255,0)");
  cx.fillStyle = g;
  cx.fillRect(0,0,64,64);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  return tex;
}
const spriteTex = makeSpriteTexture();

const positions = new Float32Array(MAX_PARTICLES * 3);
const colors    = new Float32Array(MAX_PARTICLES * 3);
const alphas    = new Float32Array(MAX_PARTICLES);
const alive     = new Float32Array(MAX_PARTICLES);
const maxLife   = new Float32Array(MAX_PARTICLES);
const velocity  = new Float32Array(MAX_PARTICLES * 3);

const attractMul = new Float32Array(MAX_PARTICLES);
const targetX = new Float32Array(MAX_PARTICLES);
const targetY = new Float32Array(MAX_PARTICLES);
const targetZ = new Float32Array(MAX_PARTICLES);

const pGeom = new THREE.BufferGeometry();
pGeom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
pGeom.setAttribute("color",    new THREE.BufferAttribute(colors, 3));
pGeom.setAttribute("aAlpha",   new THREE.BufferAttribute(alphas, 1));

for (let i=0;i<MAX_PARTICLES;i++){
  alive[i] = 0;
  maxLife[i] = P_LIFE;
  attractMul[i] = 1.0;
  positions[i*3+1] = -999;
  alphas[i]=0;
}

/* ============================================================
   âœ… FIX XR mÃ³vil:
   - En "immersive-ar" de mÃ³vil, uSize=22 (Quest) es ENANO.
   - Detectamos si la sesiÃ³n tiene mandos (tracked-pointer+gamepad):
       * si NO â†’ mÃ³vil AR â†’ tamaÃ±o grande
       * si SÃ â†’ headset â†’ tamaÃ±o normal
   ============================================================ */
const isProbablyMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

// calibres
const POINT_SIZE_XR_HEADSET = 22.0;     // Quest / visor
const POINT_SIZE_XR_MOBILE  = 64.0;     // ðŸ‘ˆ mÃ³vil en XR (AR handheld)
const POINT_SIZE_FLAT_MOBILE = 44.0;    // mÃ³vil sin XR (te iba bien)
const POINT_SIZE_FLAT_DESKTOP = 28.0;

function xrLooksLikeHeadset(session){
  if (!session) return false;

  // Si hay tracked-pointer con gamepad, casi seguro es visor con mandos (Quest)
  for (const src of session.inputSources){
    if (src?.targetRayMode === "tracked-pointer" && src?.gamepad) return true;
  }
  return false;
}

function applyParticlePointSize(session = null){
  const presenting = renderer.xr.isPresenting === true;

  if (!presenting){
    pMat.uniforms.uSize.value = isProbablyMobile ? POINT_SIZE_FLAT_MOBILE : POINT_SIZE_FLAT_DESKTOP;
    return;
  }

  // Estamos en XR:
  const headset = xrLooksLikeHeadset(session ?? renderer.xr.getSession?.());
  if (headset){
    pMat.uniforms.uSize.value = POINT_SIZE_XR_HEADSET;
  } else {
    // XR en mÃ³vil (AR handheld) â†’ agranda fuerte
    pMat.uniforms.uSize.value = isProbablyMobile ? POINT_SIZE_XR_MOBILE : POINT_SIZE_XR_HEADSET;
  }
}

const pMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  depthTest: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uMap: { value: spriteTex },
    uSize: { value: POINT_SIZE_XR_HEADSET }
  },
  vertexShader: `
    attribute vec3 color;
    attribute float aAlpha;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uSize;
    void main(){
      vColor = color;
      vAlpha = aAlpha;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * mvPosition;

      float dist = -mvPosition.z;

      // tamaÃ±o ~ 1/dist, pero con mÃ­nimo (para evitar micro en XR)
      float s = uSize * (1.0 / max(0.18, dist));
      gl_PointSize = max(3.0, s);
    }
  `,
  fragmentShader: `
    uniform sampler2D uMap;
    varying vec3 vColor;
    varying float vAlpha;
    void main(){
      vec4 tex = texture2D(uMap, gl_PointCoord);
      float a = tex.a * vAlpha;
      if (a < 0.02) discard;
      vec3 col = vColor * tex.a;
      gl_FragColor = vec4(col, a);
    }
  `
});

const points = new THREE.Points(pGeom, pMat);
points.frustumCulled = false;
points.renderOrder = 999;
scene.add(points);

// sprite cometa
const cometMat = new THREE.SpriteMaterial({
  map: spriteTex,
  transparent: true,
  depthWrite: false,
  depthTest: false,
  blending: THREE.AdditiveBlending,
  opacity: 0.0
});
const cometSprite = new THREE.Sprite(cometMat);
cometSprite.visible = false;
cometSprite.renderOrder = 1000;
scene.add(cometSprite);

// âœ… Evita que en mÃ³vil se vea el primer frame del vÃ­deo (pausado) detrÃ¡s del overlay
screen.visible = false;
frameGroup.visible = false;
points.visible = false;      // opcional: partÃ­culas
cometSprite.visible = false; // opcional: cometa

// temp vectors
let pCursor = 0;
const tmpSpawn = new THREE.Vector3();
const tmpTarget = new THREE.Vector3();
const tmpDir = new THREE.Vector3();
const tmpPos = new THREE.Vector3();
const tmpCamDir   = new THREE.Vector3();
const tmpCamUp    = new THREE.Vector3();
const tmpCamRight = new THREE.Vector3();
const tmpViewerPos = new THREE.Vector3();
const tmpViewerEnd = new THREE.Vector3();
const tmpLocal = new THREE.Vector3();

let cometTrailAcc = 0;
let cometInited = false;
const cometPos = new THREE.Vector3();
const cometPrev = new THREE.Vector3();
const cometDir  = new THREE.Vector3();

// util
function pickTarget(isRight){ return isRight ? cornerTR : cornerTL; }
function pickMobileSpawn(isRight){ return isRight ? cornerBR : cornerBL; }
function smoothstep01(x){ x = Math.max(0, Math.min(1, x)); return x*x*(3 - 2*x); }

// ==================== VIEWER POS ====================
function randomViewerWorldPos(out, zNear, zFar, xMax, yMax){
  const camPos = camera.getWorldPosition(tmpPos);
  camera.getWorldDirection(tmpCamDir).normalize();
  tmpCamUp.set(0,1,0).applyQuaternion(camera.quaternion).normalize();
  tmpCamRight.copy(tmpCamDir).cross(tmpCamUp).normalize();

  const z = zNear + Math.random() * (zFar - zNear);
  const x = (Math.random()*2 - 1) * xMax;
  const y = (Math.random()*2 - 1) * yMax;

  out.copy(camPos)
    .addScaledVector(tmpCamDir, z)
    .addScaledVector(tmpCamRight, x)
    .addScaledVector(tmpCamUp, y);

  return out;
}

function randomNearViewerTarget(out){
  return randomViewerWorldPos(
    out,
    TITLE_TO_VIEWER_Z_NEAR,
    TITLE_TO_VIEWER_Z_FAR,
    TITLE_TO_VIEWER_X_MAX,
    TITLE_TO_VIEWER_Y_MAX
  );
}

// spawn midi particles
function spawnParticlesFrom(worldPos, warm, isRightSide){
  const t = pickTarget(isRightSide);

  for (let k=0;k<P_SPAWN;k++){
    const i = pCursor;
    pCursor = (pCursor + 1) % MAX_PARTICLES;

    alive[i] = P_LIFE;
    maxLife[i] = P_LIFE;
    attractMul[i] = 1.0;

    const sx = worldPos.x + (Math.random()-0.5)*0.04;
    const sy = worldPos.y + (Math.random()-0.5)*0.04;
    const sz = worldPos.z + (Math.random()-0.5)*0.04;

    positions[i*3+0] = sx;
    positions[i*3+1] = sy;
    positions[i*3+2] = sz;

    let vx = (Math.random()-0.5)*0.07;
    let vy = 0.34 + Math.random()*0.18;
    let vz = (Math.random()-0.5)*0.07;

    tmpSpawn.set(sx, sy, sz);
    tmpDir.copy(t).sub(tmpSpawn).normalize();
    vx += tmpDir.x * TARGET_BIAS_PUSH;
    vy += tmpDir.y * TARGET_BIAS_PUSH;
    vz += tmpDir.z * TARGET_BIAS_PUSH;

    velocity[i*3+0] = vx;
    velocity[i*3+1] = vy;
    velocity[i*3+2] = vz;

    targetX[i] = t.x;
    targetY[i] = t.y;
    targetZ[i] = t.z;

    // âœ… Colores por mano:
    //   - Derecha: morado
    //   - Izquierda: blanco (con un toque lavanda suave)
    if (isRightSide){
      const pr = 0.70 + 0.20*Math.random();
      const pg = 0.25 + 0.10*Math.random();
      const pb = 1.00;
      colors[i*3+0] = pr;
      colors[i*3+1] = pg;
      colors[i*3+2] = pb;
    } else {
      const w = 0.92 + 0.08*Math.random();
      colors[i*3+0] = w;
      colors[i*3+1] = w;
      colors[i*3+2] = 1.0;
    }

    alphas[i] = 1.0;
  }

  pGeom.attributes.position.needsUpdate = true;
  pGeom.attributes.color.needsUpdate = true;
  pGeom.attributes.aAlpha.needsUpdate = true;
}

// spawn title particles (entorno): alternadas morado/blanco
function spawnTitleParticlesAt(worldPos, warm){
  const COUNT = 2;

  for (let k=0;k<COUNT;k++){
    const i = pCursor;
    pCursor = (pCursor + 1) % MAX_PARTICLES;

    alive[i] = TITLE_PARTICLE_LIFE;
    maxLife[i] = TITLE_PARTICLE_LIFE;
    attractMul[i] = TITLE_TO_VIEWER_ATTR_MUL;

    const sx = worldPos.x + (Math.random()-0.5)*0.05;
    const sy = worldPos.y + (Math.random()-0.5)*0.05;
    const sz = worldPos.z + (Math.random()-0.5)*0.05;

    positions[i*3+0] = sx;
    positions[i*3+1] = sy;
    positions[i*3+2] = sz;

    randomNearViewerTarget(tmpTarget);
    targetX[i] = tmpTarget.x;
    targetY[i] = tmpTarget.y;
    targetZ[i] = tmpTarget.z;

    let vx = (Math.random()-0.5)*0.030;
    let vy = (Math.random()-0.5)*0.030;
    let vz = (Math.random()-0.5)*0.030;

    tmpDir.copy(tmpTarget).sub(tmpSpawn.set(sx,sy,sz));
    const d = tmpDir.length();
    if (d > 0.0001){
      tmpDir.multiplyScalar(1.0 / d);
      vx += tmpDir.x * TITLE_TO_VIEWER_PUSH;
      vy += tmpDir.y * TITLE_TO_VIEWER_PUSH;
      vz += tmpDir.z * TITLE_TO_VIEWER_PUSH;
    }

    velocity[i*3+0] = vx;
    velocity[i*3+1] = vy;
    velocity[i*3+2] = vz;

    // âœ… Entorno alternado
    const alt = (ENV_ALT++ & 1);
    if (alt === 0){
      // morado
      colors[i*3+0] = 0.72 + 0.18*Math.random();
      colors[i*3+1] = 0.22 + 0.10*Math.random();
      colors[i*3+2] = 1.00;
    } else {
      // blanco
      const w = 0.94 + 0.06*Math.random();
      colors[i*3+0] = w;
      colors[i*3+1] = w;
      colors[i*3+2] = 1.0;
    }

    alphas[i] = 1.0;
  }

  pGeom.attributes.position.needsUpdate = true;
  pGeom.attributes.color.needsUpdate = true;
  pGeom.attributes.aAlpha.needsUpdate = true;
}

function updateParticles(dt){
  for (let i=0;i<MAX_PARTICLES;i++){
    if (alive[i] <= 0) continue;

    alive[i] -= dt;

    const ml = Math.max(0.001, maxLife[i]);
    const a = Math.max(0, alive[i] / ml);
    const fade = a * a;
    alphas[i] = fade;

    if (attractMul[i] > 0.0001){
      tmpPos.set(positions[i*3+0], positions[i*3+1], positions[i*3+2]);
      tmpTarget.set(targetX[i], targetY[i], targetZ[i]);
      tmpDir.copy(tmpTarget).sub(tmpPos);

      const dist = tmpDir.length();
      if (dist > 0.001){
        tmpDir.multiplyScalar(1.0 / dist);
        const pull = TARGET_ATTRACT * attractMul[i] * dt;
        velocity[i*3+0] += tmpDir.x * pull;
        velocity[i*3+1] += tmpDir.y * pull;
        velocity[i*3+2] += tmpDir.z * pull;
      }
    }

    positions[i*3+0] += velocity[i*3+0] * dt * PARTICLE_SPEED;
    positions[i*3+1] += velocity[i*3+1] * dt * PARTICLE_SPEED;
    positions[i*3+2] += velocity[i*3+2] * dt * PARTICLE_SPEED;

    velocity[i*3+0] *= (1 - dt*1.05);
    velocity[i*3+1] *= (1 - dt*0.55);
    velocity[i*3+2] *= (1 - dt*1.05);

    if (alive[i] <= 0){
      positions[i*3+1] = -999;
      alphas[i] = 0;
    }
  }
  pGeom.attributes.position.needsUpdate = true;
  pGeom.attributes.aAlpha.needsUpdate = true;
}

function spawnLeftViewerParticles(){
  if (!LEFT_VIEWER_PARTICLES) return;
  if (Math.random() > LEFT_VIEWER_SPAWN_PROB) return;

  for (let s=0; s<LEFT_VIEWER_SPAWNS_PER_HIT; s++){
    randomViewerWorldPos(tmpViewerPos, VIEWER_Z_NEAR, VIEWER_Z_FAR, VIEWER_X_MAX, VIEWER_Y_MAX);
    spawnParticlesFrom(tmpViewerPos, 0.90, false);
  }
}

function updateTitleParticles(t, dt){
  if (TITLE_PARTICLE_RATE <= 0) return;
  if (t < TITLE_PARTICLES_START || t > TITLE_PARTICLES_END) return;

  titleAcc += dt * TITLE_PARTICLE_RATE;
  const n = Math.floor(titleAcc);
  if (n <= 0) return;
  titleAcc -= n;

  for (let i=0;i<n;i++){
    randomViewerWorldPos(tmpViewerPos, TITLE_Z_NEAR, TITLE_Z_FAR, TITLE_X_MAX, TITLE_Y_MAX);
    spawnTitleParticlesAt(tmpViewerPos, TITLE_PARTICLE_WARM);
  }
}

// ==================== COMETA: PERÃMETRO REDONDEADO REAL ====================
function roundedRectPerimeterPoint(u, outWorld){
  u = ((u % 1) + 1) % 1;

  const hw = outerW * 0.5;
  const hh = outerH * 0.5;
  const r  = Math.min(radius, hw - 0.001, hh - 0.001);

  const topLen  = (outerW - 2*r);
  const sideLen = (outerH - 2*r);
  const arcLen  = (Math.PI * 0.5) * r;

  const total = 2*topLen + 2*sideLen + 4*arcLen;
  let s = u * total;

  const setLocalToWorld = (x,y)=>{
    tmpLocal.set(x, y, zFront);
    outWorld.copy(tmpLocal);
    frameGroup.localToWorld(outWorld);
    return outWorld;
  };

  if (s <= topLen){
    const x = (-hw + r) + (s / topLen) * topLen;
    return setLocalToWorld(x, +hh);
  }
  s -= topLen;

  if (s <= arcLen){
    const a = (Math.PI*0.5) - (s / arcLen) * (Math.PI*0.5);
    const cx = (hw - r), cy = (hh - r);
    return setLocalToWorld(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
  }
  s -= arcLen;

  if (s <= sideLen){
    const y = (+hh - r) - (s / sideLen) * sideLen;
    return setLocalToWorld(+hw, y);
  }
  s -= sideLen;

  if (s <= arcLen){
    const a = 0 - (s / arcLen) * (Math.PI*0.5);
    const cx = (hw - r), cy = (-hh + r);
    return setLocalToWorld(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
  }
  s -= arcLen;

  if (s <= topLen){
    const x = (+hw - r) - (s / topLen) * topLen;
    return setLocalToWorld(x, -hh);
  }
  s -= topLen;

  if (s <= arcLen){
    const a = (-Math.PI*0.5) - (s / arcLen) * (Math.PI*0.5);
    const cx = (-hw + r), cy = (-hh + r);
    return setLocalToWorld(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
  }
  s -= arcLen;

  if (s <= sideLen){
    const y = (-hh + r) + (s / sideLen) * sideLen;
    return setLocalToWorld(-hw, y);
  }
  s -= sideLen;

  {
    const a = (-Math.PI) - (s / arcLen) * (Math.PI*0.5);
    const cx = (-hw + r), cy = (hh - r);
    return setLocalToWorld(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
  }
}

function viewerEndWorldPos(out){
  const camPos = camera.getWorldPosition(tmpPos);
  camera.getWorldDirection(tmpCamDir).normalize();
  tmpCamUp.set(0,1,0).applyQuaternion(camera.quaternion).normalize();
  out.copy(camPos)
    .addScaledVector(tmpCamDir, COMET_END_Z)
    .addScaledVector(tmpCamUp, COMET_END_Y);
  return out;
}

function spawnCometTrail(worldPos, dt){
  cometTrailAcc += dt * COMET_TRAIL_RATE;
  const n = Math.floor(cometTrailAcc);
  if (n <= 0) return;
  cometTrailAcc -= n;

  cometDir.copy(worldPos).sub(cometPrev);
  const len = cometDir.length();
  if (len > 0.0001) cometDir.multiplyScalar(1 / len);
  else cometDir.set(0, 1, 0);

  viewerEndWorldPos(tmpViewerEnd);

  for (let s=0; s<n; s++){
    const i = pCursor;
    pCursor = (pCursor + 1) % MAX_PARTICLES;

    alive[i] = COMET_TRAIL_LIFE;
    maxLife[i] = COMET_TRAIL_LIFE;
    attractMul[i] = COMET_ATTRACT_MUL;

    const sx = worldPos.x + (Math.random()-0.5)*0.024;
    const sy = worldPos.y + (Math.random()-0.5)*0.024;
    const sz = worldPos.z + (Math.random()-0.5)*0.024;

    positions[i*3+0] = sx;
    positions[i*3+1] = sy;
    positions[i*3+2] = sz;

    const back = 0.55 + Math.random()*0.70;
    let vx = -cometDir.x * back + (Math.random()-0.5)*0.06;
    let vy = -cometDir.y * back + (0.10 + Math.random()*0.22);
    let vz = -cometDir.z * back + (Math.random()-0.5)*0.06;

    tmpDir.copy(tmpViewerEnd).sub(tmpSpawn.set(sx,sy,sz));
    const d2 = tmpDir.length();
    if (d2 > 0.0001){
      tmpDir.multiplyScalar(1 / d2);
      vx += tmpDir.x * COMET_TO_VIEWER_PUSH;
      vy += tmpDir.y * COMET_TO_VIEWER_PUSH;
      vz += tmpDir.z * COMET_TO_VIEWER_PUSH;
    }

    velocity[i*3+0] = vx;
    velocity[i*3+1] = vy;
    velocity[i*3+2] = vz;

    targetX[i] = tmpViewerEnd.x;
    targetY[i] = tmpViewerEnd.y;
    targetZ[i] = tmpViewerEnd.z;

    // âœ… Cometa alternado morado/blanco
    const alt = (COMET_ALT++ & 1);
    if (alt === 0){
      colors[i*3+0] = 0.74 + 0.16*Math.random();
      colors[i*3+1] = 0.22 + 0.10*Math.random();
      colors[i*3+2] = 1.00;
    } else {
      const w = 0.95 + 0.05*Math.random();
      colors[i*3+0] = w;
      colors[i*3+1] = w;
      colors[i*3+2] = 1.0;
    }

    alphas[i] = 1.0;
  }

  pGeom.attributes.position.needsUpdate = true;
  pGeom.attributes.color.needsUpdate = true;
  pGeom.attributes.aAlpha.needsUpdate = true;
}

function updateCometIntro(t, dt){
  if (!COMET_ENABLED) return;

  if (t >= INTRO_NO_MIDI_SECONDS){
    cometSprite.visible = false;
    cometMat.opacity = 0.0;
    cometInited = false;
    return;
  }

  cometSprite.visible = true;

  // âœ… Cabeza del cometa: morado â†” blanco (suave)
  const ct = 0.5 + 0.5*Math.sin(t * 5.2);
  cometMat.color.setRGB(lerp(1.0, 0.72, ct), lerp(1.0, 0.22, ct), 1.0);

  const p = Math.max(0, Math.min(1, t / INTRO_NO_MIDI_SECONDS));
  const fadeIn  = smoothstep01(p / 0.10);
  const fadeOut = 1.0 - smoothstep01((p - 0.92) / 0.08);
  cometMat.opacity = 0.95 * fadeIn * fadeOut;

  const u = smoothstep01(p) * COMET_TURNS;
  // Zig-zag comet path
const camPos = camera.getWorldPosition(tmpPos);
camera.getWorldDirection(tmpCamDir).normalize();
tmpCamUp.set(0,1,0).applyQuaternion(camera.quaternion).normalize();
tmpCamRight.copy(tmpCamDir).cross(tmpCamUp).normalize();

// progress
const pr = Math.max(0, Math.min(1, t / INTRO_NO_MIDI_SECONDS));
// Base forward motion
const z = 0.6 + pr * 0.6;
const x = Math.sin(pr * 10.0) * 0.30;
const y = Math.sin(pr * 6.0) * 0.15;

// compute world pos
cometPos.copy(camPos)
  .addScaledVector(tmpCamDir, z)
  .addScaledVector(tmpCamRight, x)
  .addScaledVector(tmpCamUp, y);


  cometSprite.position.copy(cometPos);
  const pulse = 0.80 + 0.20*Math.sin(t * 6.8);
  cometSprite.scale.setScalar(COMET_SPRITE_SCALE * pulse);

  if (!cometInited){
    cometPrev.copy(cometPos);
    cometInited = true;
  }
  spawnCometTrail(cometPos, dt);
  cometPrev.copy(cometPos);
}

// ==================== VIBRACIÃ“N MÃ“VIL ====================
let lastMobileVibeAt = -999;
function mobileVibrate(){
  // En mÃ³vil no hay intensidad: usamos duraciÃ³n fija + gap mÃ­nimo para que se note.
  const now = performance.now();
  if (now - lastMobileVibe < 60) return; // min gap (ms)
  lastMobileVibe = now;
  try{ navigator.vibrate(28); }catch(e){}
}

// ==================== HÃPTICA + MIDI ====================
let rightHaptic = null;
let leftHaptic = null;

let rightTimes = [];
let leftTimes  = [];
let rightIdx = 0;
let leftIdx  = 0;

let lastVideoTimeForLoop = 0;
let lastPulseRightAt = -999;
let lastPulseLeftAt  = -999;

function updateHaptics(session){
  rightHaptic = null;
  leftHaptic = null;

  for (const src of session.inputSources){
    if (!src.gamepad) continue;
    const acts = src.gamepad.hapticActuators;
    if (!acts || acts.length === 0) continue;

    if (src.handedness === "right") rightHaptic = acts[0];
    if (src.handedness === "left")  leftHaptic  = acts[0];
  }

  log(rightHaptic ? "âœ… HÃ¡ptica derecha OK" : "â„¹ï¸ Sin hÃ¡ptica derecha (modo mÃ³vil)");
  log(leftHaptic  ? "âœ… HÃ¡ptica izquierda OK" : "â„¹ï¸ Sin hÃ¡ptica izquierda (modo mÃ³vil)");
}

function pulseController(actuator){
  if (!actuator) return false;
  try{ actuator.pulse(HAPTIC_INTENSITY, HAPTIC_DURATION_MS); return true; }catch{ return false; }
}

function resyncIndex(times, midiTime){
  let lo = 0, hi = times.length;
  while (lo < hi){
    const mid = (lo + hi) >> 1;
    if (times[mid] <= midiTime) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}

function tickHand(times, which, videoTime, midiTime){
  if (times.length === 0) return;

  if (which === "R"){
    while (rightIdx < times.length){
      const nt = times[rightIdx];
      const diff = nt - midiTime;
      if (diff <= HAPTIC_WINDOW){
        if (videoTime - lastPulseRightAt > MIN_PULSE_GAP){
          pulseController(rightHaptic);
          lastPulseRightAt = videoTime;

          if (controllerRightObj){
            controllerRightObj.getWorldPosition(tmpSpawn);
            spawnParticlesFrom(tmpSpawn, 0.55, true);
          } else {
            spawnParticlesFrom(pickMobileSpawn(true), 0.55, true);
          }
          // also spawn from corner
          spawnParticlesFrom(pickMobileSpawn(true), 0.55, true);
        }
        rightIdx++;
        continue;
      }
      break;
    }
  } else {
    while (leftIdx < times.length){
      const nt = times[leftIdx];
      const diff = nt - midiTime;
      if (diff <= HAPTIC_WINDOW){
        if (videoTime - lastPulseLeftAt > MIN_PULSE_GAP){
          const ok = pulseController(leftHaptic);
          if (!ok) mobileVibrate();

          lastPulseLeftAt = videoTime;
          frameEnergy = Math.min(1.0, frameEnergy + 0.16);

          if (controllerLeftObj){
            controllerLeftObj.getWorldPosition(tmpSpawn);
            spawnParticlesFrom(tmpSpawn, 0.90, false);
          } else {
            spawnParticlesFrom(pickMobileSpawn(false), 0.90, false);
          }
          // also spawn from corner
          spawnParticlesFrom(pickMobileSpawn(false), 0.90, false);

          spawnLeftViewerParticles();
        }
        leftIdx++;
        continue;
      }
      break;
    }
  }
}

function tickHaptics(videoTime){
  if (rightTimes.length === 0 && leftTimes.length === 0) return;

  if (videoTime + 0.05 < lastVideoTimeForLoop){
    const mr = Math.max(0, videoTime - MIDI_OFFSET_RIGHT);
    const ml = Math.max(0, videoTime - MIDI_OFFSET_LEFT);
    rightIdx = resyncIndex(rightTimes, mr);
    leftIdx  = resyncIndex(leftTimes,  ml);
  }
  lastVideoTimeForLoop = videoTime;

  const midiTimeR = videoTime - MIDI_OFFSET_RIGHT;
  const midiTimeL = videoTime - MIDI_OFFSET_LEFT;

  if (midiTimeR >= 0) tickHand(rightTimes, "R", videoTime, midiTimeR);
  if (midiTimeL >= 0) tickHand(leftTimes,  "L", videoTime, midiTimeL);
}

// ==================== RESET DE EXPERIENCIA (sin recargar) ====================
// Nota: esto NO elimina nada; solo reinicia contadores/estado para poder iniciar de nuevo.
function resetMidiHapticsState(){
  rightIdx = 0;
  leftIdx  = 0;
  lastVideoTimeForLoop = 0;
  lastPulseRightAt = -999;
  lastPulseLeftAt  = -999;
  lastMobileVibeAt = -999;

  // Si ya tenemos los tiempos MIDI cargados, resincroniza con el tiempo actual del vÃ­deo
  if (rightTimes.length || leftTimes.length){
    const mr = Math.max(0, video.currentTime - MIDI_OFFSET_RIGHT);
    const ml = Math.max(0, video.currentTime - MIDI_OFFSET_LEFT);
    if (rightTimes.length) rightIdx = resyncIndex(rightTimes, mr);
    if (leftTimes.length)  leftIdx  = resyncIndex(leftTimes,  ml);
  }
}

function resetParticlesState(){
  pCursor = 0;
  for (let i=0;i<MAX_PARTICLES;i++){
    alive[i] = 0;
    alphas[i] = 0;
    positions[i*3+1] = -999; // fuera de cÃ¡mara como en init
  }
  if (pGeom?.attributes?.position) pGeom.attributes.position.needsUpdate = true;
  if (pGeom?.attributes?.aAlpha)   pGeom.attributes.aAlpha.needsUpdate   = true;
}

function resetExperienceState(){
  // Reinicio visual + MIDI/hÃ¡ptica + partÃ­culas
  try{
    video.pause();
    // Si estÃ¡ al final, reinicia a 0 para que vuelva a disparar MIDI desde el principio
    if (video.ended || video.currentTime > 0.001){
      video.currentTime = 0;
    }
  }catch{}
  resetMidiHapticsState();
  resetParticlesState();
}


// ==================== RENDER LOOP ====================
renderer.setAnimationLoop(()=>{
  if (video.readyState >= 2) videoTex.needsUpdate = true;

  scene.updateMatrixWorld(true);
  updateVideoCornersWorld();

  const t = video.currentTime;

  while (nextCue < cues.length && t >= cues[nextCue].t){
    setupText(cues[nextCue].text, cues[nextCue].type || "text");
    nextCue++;
  }

  const dt = Math.max(0, t - prevVideoT);
  prevVideoT = t;

  stepType(dt);
  updateTitleLives(dt);
  updateTextFadeAndCleanup(t);

  updateTitleParticles(t, dt);

  tickHaptics(t);
  updateCometIntro(t, dt);

  frameEnergy *= Math.exp(-dt * 3.2);
  framePhase += dt * (0.18 + frameEnergy * 0.25);
  drawGradient(framePhase, frameEnergy);
  frameMat.opacity = 0.78 + frameEnergy * 0.14;

  updateParticles(dt);
  renderer.render(scene, camera);
});

// ==================== BOTONES ====================
const btnStart = document.getElementById("startExperience");

// âœ… Si la experiencia ya terminÃ³, recargamos en el siguiente "Iniciar" (gesto de usuario)
let NEEDS_RELOAD_AFTER_END = false;



async function enter(mode){
  const s = await navigator.xr.requestSession(mode,{
    optionalFeatures:["local-floor","bounded-floor","hand-tracking"]
  });
  renderer.xr.setSession(s);

  // âœ… aplica tamaÃ±o correcto segÃºn tipo de XR (mÃ³vil vs visor)
  applyParticlePointSize(s);

  mapGrips(s);
  updateHaptics(s);

  s.addEventListener("inputsourceschange", () => {
    mapGrips(s);
    updateHaptics(s);

    // âœ… re-evalÃºa: algunos mÃ³viles cambian inputSources tarde
    applyParticlePointSize(s);
  });

  s.addEventListener("end", () => {
    overlay.style.display = "grid";
    NEEDS_RELOAD_AFTER_END = true;
    applyParticlePointSize(null);
    resetExperienceState();
  });

  overlay.style.display = "none";
}

btnStart.onclick = async () => {
  if (NEEDS_RELOAD_AFTER_END) {
    // Ya se terminÃ³ una sesiÃ³n anterior: reinicia estado interno (sin recargar)
    NEEDS_RELOAD_AFTER_END = false;
    resetExperienceState();
  }

  try {
    loadPristinaFontNonBlocking();
    drawGradient(0, 0);

    // en modo plano
    applyParticlePointSize(null);

    video.muted = false;
    video.volume = 1.0;
    await video.play();
    log("â–¶ VÃ­deo iniciado (con sonido)");

// âœ… Ahora que el usuario ha iniciado, mostramos la escena
screen.visible = true;
frameGroup.visible = true;
points.visible = true; // opcional: partÃ­culas

try{
  // Cargamos cada MIDI por separado para que uno no bloquee al otro
  log("â³ Cargando MIDI derecha...");
  try{
    rightTimes = await loadMidiTimes(MIDI_RIGHT_URL);
    log("âœ… MIDI derecha OK (" + rightTimes.length + " notas)");
    if (rightTimes.length){
      log("   R: primera=" + rightTimes[0].toFixed(3) + "s, Ãºltima=" + rightTimes[rightTimes.length-1].toFixed(3) + "s");
    } else {
      log("âš ï¸ MIDI derecha cargÃ³ pero sin notas (Â¿archivo vacÃ­o o formato raro?)");
    }
  }catch(e){
    rightTimes = [];
    log("âš ï¸ No se pudo cargar MIDI derecha: " + (e?.message || e));
  }

  log("â³ Cargando MIDI izquierda...");
  try{
    leftTimes = await loadMidiTimes(MIDI_LEFT_URL);
    log("âœ… MIDI izquierda OK (" + leftTimes.length + " notas)");
    if (leftTimes.length){
      log("   L: primera=" + leftTimes[0].toFixed(3) + "s, Ãºltima=" + leftTimes[leftTimes.length-1].toFixed(3) + "s");
    } else {
      log("âš ï¸ MIDI izquierda cargÃ³ pero sin notas (Â¿archivo vacÃ­o o formato raro?)");
    }
  }catch(e){
    leftTimes = [];
    log("âš ï¸ No se pudo cargar MIDI izquierda: " + (e?.message || e));
  }

  // Resincroniza Ã­ndices con el tiempo actual del vÃ­deo
  const mr = Math.max(0, video.currentTime - MIDI_OFFSET_RIGHT);
  const ml = Math.max(0, video.currentTime - MIDI_OFFSET_LEFT);
  if (rightTimes.length) rightIdx = resyncIndex(rightTimes, mr);
  if (leftTimes.length)  leftIdx  = resyncIndex(leftTimes,  ml);

  log("ðŸŸ£ Listo. Offsets: R=" + MIDI_OFFSET_RIGHT + "s, L=" + MIDI_OFFSET_LEFT + "s");
  log("   (Si una mano no vibra, mira arriba si ese MIDI tiene 0 notas o si no se pudo cargar)");

  // a
}catch(e){
      log("âš ï¸ MIDI/hÃ¡ptica no disponibles: " + (e?.message || e));
    }

    
    

  } catch (e) {
    log("âŒ No se pudo iniciar: " + (e?.message || e));
  }
};

// âœ… Si venimos de un reinicio post-experiencia, auto-iniciamos tras recargar
btnAR.onclick = async () => {
  try{
    const ok = await navigator.xr.isSessionSupported("immersive-ar");
    if (!ok) throw new Error("immersive-ar no soportado en este navegador");
    await enter("immersive-ar");
  }catch(e){
    log("âŒ AR: " + (e?.message || e));
  }
};

btnVR.onclick = async () => {
  try{ await enter("immersive-vr"); }
  catch(e){ log("âŒ VR: " + (e?.message || e)); }
};

window.addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);

  // si rota el mÃ³vil en XR/plano
  applyParticlePointSize(renderer.xr.getSession?.() ?? null);
});

log("âœ… App cargada. Pulsa â€œIniciar vÃ­deoâ€.");
</script>
</body>
</html>


















